#!/usr/bin/env python3
"""
Comprehensive test script for the Achievement System
Tests all major functionality and validates improvements
"""

import sys
import os
import json
import time
from datetime import datetime, timedelta

# Add the backend directory to the path
sys.path.append('/home/desire/My_Project/Client_Project/Afritech_Bridge_lms/backend')

from src.models.user_models import db, User
from src.models.achievement_models import (
    Achievement, UserAchievement, LearningStreak, StudentPoints,
    Milestone, UserMilestone, QuestChallenge, UserQuestProgress
)
from src.services.achievement_service import AchievementService
from src.main import create_app

class AchievementSystemTester:
    def __init__(self):
        self.app = create_app()
        self.test_user_id = None
        self.results = {
            'tests_run': 0,
            'tests_passed': 0,
            'tests_failed': 0,
            'failures': []
        }
    
    def log_test(self, test_name, success, message=None):
        """Log test results"""
        self.results['tests_run'] += 1
        if success:
            self.results['tests_passed'] += 1
            print(f"‚úÖ {test_name}")
        else:
            self.results['tests_failed'] += 1
            self.results['failures'].append(f"{test_name}: {message or 'Test failed'}")
            print(f"‚ùå {test_name}: {message or 'Test failed'}")
    
    def setup_test_user(self):
        """Create a test user for testing"""
        with self.app.app_context():
            # Check if test user already exists
            test_user = User.query.filter_by(email='test_achievements@example.com').first()
            if not test_user:
                # Create test user (simplified, assumes User model structure)
                test_user = User(
                    username='achievement_tester',
                    email='test_achievements@example.com',
                    first_name='Test',
                    last_name='User'
                )
                db.session.add(test_user)
                db.session.commit()
            
            self.test_user_id = test_user.id
            print(f"üìù Test user created/found: ID {self.test_user_id}")
    
    def test_achievement_creation(self):
        """Test achievement model creation and validation"""
        with self.app.app_context():
            try:
                # Test valid achievement creation
                achievement = Achievement(
                    name='test_achievement',
                    title='Test Achievement',
                    description='A test achievement for validation',
                    category='test',
                    tier='bronze',
                    points=50,
                    criteria_type='test_criteria',
                    criteria_value=1
                )\n                db.session.add(achievement)\n                db.session.commit()\n                \n                # Test achievement is available\n                is_available = achievement.is_available()\n                \n                self.log_test(\n                    \"Achievement creation and availability check\",\n                    is_available,\n                    \"Achievement should be available after creation\"\n                )\n                \n                # Clean up\n                db.session.delete(achievement)\n                db.session.commit()\n                \n            except Exception as e:\n                self.log_test(\"Achievement creation\", False, str(e))\n    \n    def test_points_system(self):\n        \"\"\"Test student points system\"\"\"\n        with self.app.app_context():\n            try:\n                # Create or get student points\n                points = StudentPoints.query.filter_by(user_id=self.test_user_id).first()\n                if not points:\n                    points = StudentPoints(user_id=self.test_user_id)\n                    db.session.add(points)\n                    db.session.commit()\n                \n                initial_points = points.total_points\n                initial_level = points.current_level\n                \n                # Test adding points\n                points_added = points.add_points(100, 'lesson')\n                db.session.commit()\n                \n                success = (\n                    points_added == 100 and\n                    points.total_points == initial_points + 100 and\n                    points.lesson_points == 100\n                )\n                \n                self.log_test(\n                    \"Points addition system\",\n                    success,\n                    f\"Expected 100 points added, got {points_added}\"\n                )\n                \n                # Test level up mechanism\n                large_points = 1000\n                points.add_points(large_points, 'bonus')\n                db.session.commit()\n                \n                level_up_success = points.current_level > initial_level\n                \n                self.log_test(\n                    \"Level up system\",\n                    level_up_success,\n                    f\"Level should increase from {initial_level} to {points.current_level}\"\n                )\n                \n            except Exception as e:\n                self.log_test(\"Points system\", False, str(e))\n    \n    def test_streak_system(self):\n        \"\"\"Test learning streak functionality\"\"\"\n        with self.app.app_context():\n            try:\n                # Get or create streak\n                streak = LearningStreak.query.filter_by(user_id=self.test_user_id).first()\n                if not streak:\n                    streak = LearningStreak(user_id=self.test_user_id)\n                    db.session.add(streak)\n                \n                initial_streak = streak.current_streak\n                \n                # Test streak update\n                new_streak = streak.update_streak(lesson_completed=True)\n                db.session.commit()\n                \n                success = (\n                    new_streak > initial_streak and\n                    streak.total_lessons_completed > 0\n                )\n                \n                self.log_test(\n                    \"Streak update system\",\n                    success,\n                    f\"Streak should increase from {initial_streak} to {new_streak}\"\n                )\n                \n                # Test milestone detection\n                milestones_before = len(json.loads(streak.milestones_reached) if streak.milestones_reached else [])\n                \n                # Artificially set streak to trigger milestone\n                streak.current_streak = 7  # Should trigger 7-day milestone\n                streak.update_streak(lesson_completed=True)\n                \n                milestones_after = len(json.loads(streak.milestones_reached))\n                \n                milestone_success = milestones_after >= milestones_before\n                \n                self.log_test(\n                    \"Streak milestone detection\",\n                    milestone_success,\n                    f\"Milestones should be detected at streak 7\"\n                )\n                \n            except Exception as e:\n                self.log_test(\"Streak system\", False, str(e))\n    \n    def test_achievement_service(self):\n        \"\"\"Test achievement service functionality\"\"\"\n        with self.app.app_context():\n            try:\n                # Test achievement check and award\n                initial_achievements = UserAchievement.query.filter_by(user_id=self.test_user_id).count()\n                \n                # Create a simple achievement for testing\n                test_achievement = Achievement(\n                    name='test_service_achievement',\n                    title='Test Service Achievement',\n                    description='For testing service functionality',\n                    category='test',\n                    tier='bronze',\n                    points=25,\n                    criteria_type='lessons_completed',\n                    criteria_value=1\n                )\n                db.session.add(test_achievement)\n                db.session.commit()\n                \n                # Trigger achievement check\n                newly_awarded = AchievementService.check_and_award_achievements(\n                    self.test_user_id,\n                    'lesson_complete',\n                    {'course_id': 1, 'lesson_id': 1}\n                )\n                \n                final_achievements = UserAchievement.query.filter_by(user_id=self.test_user_id).count()\n                \n                success = len(newly_awarded) > 0 and final_achievements > initial_achievements\n                \n                self.log_test(\n                    \"Achievement service check and award\",\n                    success,\n                    f\"Should award achievement for lesson completion\"\n                )\n                \n                # Test achievement summary\n                summary = AchievementService.get_user_achievements_summary(self.test_user_id)\n                \n                summary_success = (\n                    'achievements' in summary and\n                    'points' in summary and\n                    'streak' in summary and\n                    isinstance(summary['achievements']['total_earned'], int)\n                )\n                \n                self.log_test(\n                    \"Achievement summary generation\",\n                    summary_success,\n                    \"Summary should contain achievements, points, and streak data\"\n                )\n                \n                # Clean up\n                db.session.delete(test_achievement)\n                db.session.commit()\n                \n            except Exception as e:\n                self.log_test(\"Achievement service\", False, str(e))\n    \n    def test_milestone_system(self):\n        \"\"\"Test milestone functionality\"\"\"\n        with self.app.app_context():\n            try:\n                # Create test milestone\n                test_milestone = Milestone(\n                    name='test_milestone',\n                    title='Test Milestone',\n                    description='A test milestone',\n                    milestone_type='platform',\n                    criteria_type='total_lessons',\n                    criteria_value=1,\n                    points_reward=50\n                )\n                db.session.add(test_milestone)\n                db.session.commit()\n                \n                initial_milestones = UserMilestone.query.filter_by(user_id=self.test_user_id).count()\n                \n                # Check milestones\n                new_milestones = AchievementService.check_milestones(\n                    self.test_user_id,\n                    'platform',\n                    {'total_lessons': 5}  # Should exceed criteria_value of 1\n                )\n                \n                final_milestones = UserMilestone.query.filter_by(user_id=self.test_user_id).count()\n                \n                success = len(new_milestones) > 0 or final_milestones > initial_milestones\n                \n                self.log_test(\n                    \"Milestone check and award\",\n                    success,\n                    \"Should award milestone when criteria is met\"\n                )\n                \n                # Clean up\n                db.session.delete(test_milestone)\n                db.session.commit()\n                \n            except Exception as e:\n                self.log_test(\"Milestone system\", False, str(e))\n    \n    def test_quest_system(self):\n        \"\"\"Test quest challenge functionality\"\"\"\n        with self.app.app_context():\n            try:\n                # Create test quest\n                now = datetime.utcnow()\n                test_quest = QuestChallenge(\n                    name='test_quest',\n                    title='Test Quest',\n                    description='A test quest challenge',\n                    challenge_type='daily',\n                    difficulty='easy',\n                    objectives='[{\"key\": \"lessons\", \"title\": \"Complete Lessons\", \"target\": 3}]',\n                    progress_tracking='{\"lessons\": {\"type\": \"counter\", \"max\": 3}}',\n                    start_date=now,\n                    end_date=now + timedelta(days=1),\n                    completion_points=100,\n                    completion_xp=50\n                )\n                db.session.add(test_quest)\n                db.session.commit()\n                \n                # Test quest availability\n                availability_success = test_quest.is_available()\n                \n                self.log_test(\n                    \"Quest availability check\",\n                    availability_success,\n                    \"Quest should be available within time bounds\"\n                )\n                \n                # Test starting quest\n                start_success, start_message = AchievementService.start_quest(self.test_user_id, test_quest.id)\n                \n                self.log_test(\n                    \"Quest start functionality\",\n                    start_success,\n                    start_message\n                )\n                \n                if start_success:\n                    # Test quest progress update\n                    progress_success = AchievementService.update_quest_progress(\n                        self.test_user_id,\n                        test_quest.id,\n                        'lessons',\n                        2\n                    )\n                    \n                    self.log_test(\n                        \"Quest progress update\",\n                        progress_success,\n                        \"Should update quest progress\"\n                    )\n                \n                # Clean up\n                db.session.delete(test_quest)\n                db.session.commit()\n                \n            except Exception as e:\n                self.log_test(\"Quest system\", False, str(e))\n    \n    def test_error_handling(self):\n        \"\"\"Test error handling in various scenarios\"\"\"\n        with self.app.app_context():\n            try:\n                # Test with invalid user ID\n                invalid_result = AchievementService.check_and_award_achievements(\n                    99999,  # Non-existent user\n                    'lesson_complete',\n                    {}\n                )\n                \n                # Should return empty list, not crash\n                error_handling_success = isinstance(invalid_result, list) and len(invalid_result) == 0\n                \n                self.log_test(\n                    \"Error handling for invalid user ID\",\n                    error_handling_success,\n                    \"Should handle invalid user ID gracefully\"\n                )\n                \n                # Test with invalid event type\n                invalid_event_result = AchievementService.check_and_award_achievements(\n                    self.test_user_id,\n                    '',  # Empty event type\n                    {}\n                )\n                \n                event_handling_success = isinstance(invalid_event_result, list)\n                \n                self.log_test(\n                    \"Error handling for invalid event type\",\n                    event_handling_success,\n                    \"Should handle invalid event type gracefully\"\n                )\n                \n                # Test summary with invalid user\n                invalid_summary = AchievementService.get_user_achievements_summary(99999)\n                \n                summary_error_success = (\n                    isinstance(invalid_summary, dict) and\n                    'achievements' in invalid_summary\n                )\n                \n                self.log_test(\n                    \"Error handling for invalid user summary\",\n                    summary_error_success,\n                    \"Should return valid structure even for invalid user\"\n                )\n                \n            except Exception as e:\n                self.log_test(\"Error handling tests\", False, str(e))\n    \n    def test_performance(self):\n        \"\"\"Test performance of key operations\"\"\"\n        with self.app.app_context():\n            try:\n                # Test achievement check performance\n                start_time = time.time()\n                \n                for i in range(10):\n                    AchievementService.check_and_award_achievements(\n                        self.test_user_id,\n                        'lesson_complete',\n                        {'lesson_id': i}\n                    )\n                \n                end_time = time.time()\n                duration = end_time - start_time\n                \n                # Should complete 10 checks in under 1 second\n                performance_success = duration < 1.0\n                \n                self.log_test(\n                    f\"Performance test (10 achievement checks in {duration:.3f}s)\",\n                    performance_success,\n                    f\"Should complete in under 1 second, took {duration:.3f}s\"\n                )\n                \n                # Test summary generation performance\n                start_time = time.time()\n                summary = AchievementService.get_user_achievements_summary(self.test_user_id)\n                end_time = time.time()\n                duration = end_time - start_time\n                \n                summary_performance = duration < 0.5\n                \n                self.log_test(\n                    f\"Summary generation performance ({duration:.3f}s)\",\n                    summary_performance,\n                    f\"Should complete in under 0.5 seconds, took {duration:.3f}s\"\n                )\n                \n            except Exception as e:\n                self.log_test(\"Performance tests\", False, str(e))\n    \n    def cleanup_test_data(self):\n        \"\"\"Clean up test data\"\"\"\n        with self.app.app_context():\n            try:\n                # Remove test user achievements\n                UserAchievement.query.filter_by(user_id=self.test_user_id).delete()\n                \n                # Remove test user milestones\n                UserMilestone.query.filter_by(user_id=self.test_user_id).delete()\n                \n                # Remove test user quest progress\n                UserQuestProgress.query.filter_by(user_id=self.test_user_id).delete()\n                \n                # Reset test user's points and streak\n                points = StudentPoints.query.filter_by(user_id=self.test_user_id).first()\n                if points:\n                    db.session.delete(points)\n                \n                streak = LearningStreak.query.filter_by(user_id=self.test_user_id).first()\n                if streak:\n                    db.session.delete(streak)\n                \n                # Remove test achievements, milestones, quests\n                Achievement.query.filter(\n                    Achievement.name.like('test_%')\n                ).delete(synchronize_session='fetch')\n                \n                Milestone.query.filter(\n                    Milestone.name.like('test_%')\n                ).delete(synchronize_session='fetch')\n                \n                QuestChallenge.query.filter(\n                    QuestChallenge.name.like('test_%')\n                ).delete(synchronize_session='fetch')\n                \n                db.session.commit()\n                print(\"üßπ Test data cleaned up\")\n                \n            except Exception as e:\n                db.session.rollback()\n                print(f\"‚ö†Ô∏è  Error cleaning up test data: {str(e)}\")\n    \n    def run_all_tests(self):\n        \"\"\"Run all tests\"\"\"\n        print(\"üß™ Starting Achievement System Tests...\\n\")\n        \n        self.setup_test_user()\n        \n        # Run all test methods\n        self.test_achievement_creation()\n        self.test_points_system()\n        self.test_streak_system()\n        self.test_achievement_service()\n        self.test_milestone_system()\n        self.test_quest_system()\n        self.test_error_handling()\n        self.test_performance()\n        \n        # Cleanup\n        self.cleanup_test_data()\n        \n        # Print results\n        self.print_results()\n    \n    def print_results(self):\n        \"\"\"Print test results summary\"\"\"\n        print(\"\\n\" + \"=\"*60)\n        print(\"üß™ ACHIEVEMENT SYSTEM TEST RESULTS\")\n        print(\"=\"*60)\n        \n        print(f\"üìä Tests Run: {self.results['tests_run']}\")\n        print(f\"‚úÖ Tests Passed: {self.results['tests_passed']}\")\n        print(f\"‚ùå Tests Failed: {self.results['tests_failed']}\")\n        \n        success_rate = (self.results['tests_passed'] / self.results['tests_run']) * 100 if self.results['tests_run'] > 0 else 0\n        print(f\"üìà Success Rate: {success_rate:.1f}%\")\n        \n        if self.results['failures']:\n            print(\"\\n‚ùå Failed Tests:\")\n            for failure in self.results['failures']:\n                print(f\"   ‚Ä¢ {failure}\")\n        \n        if success_rate >= 80:\n            print(\"\\nüéâ Achievement System is working well!\")\n        elif success_rate >= 60:\n            print(\"\\n‚ö†Ô∏è  Achievement System needs some attention.\")\n        else:\n            print(\"\\nüö® Achievement System has significant issues.\")\n        \n        print(\"=\"*60)\n\ndef main():\n    \"\"\"Main function\"\"\"\n    tester = AchievementSystemTester()\n    tester.run_all_tests()\n    return 0 if tester.results['tests_failed'] == 0 else 1\n\nif __name__ == \"__main__\":\n    sys.exit(main())